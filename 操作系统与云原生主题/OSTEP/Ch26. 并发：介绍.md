## 线程 Thread
### 单线程/多线程比较
- 一个程序只有一个执行点（一个程序计数器）
- 多线程程序有多个执行点（多个程序计数器，都用于取指令和执行）
	- 每一个线程类似于独立的进程，但是他们共享了地址空间，所以可以访问相同的数据

### 线程切换上下文/进程切换上下文
- 对于进程，上下文切换时将状态保存到 进程控制块（Process Control Block，PCB）
- 对于线程，需要一个或多个线程控制块（Thread Control Block，TCB），保存每个线程的状态

#### 地址空间区别
- 与进程相比，线程的地址空间保持不变（不需要切换当前使用的页表）

#### 栈的区别
在简单的传统进程地址空间模型，可以称之为单线程（single-threaded）进程中

![[Pasted image 20230525135349.png]]

如左图所示，单线程进程只有一个栈，通常位于地址空间底部。

右图是多线程的进程，他拥有2个线程，因此可以看到2个栈跨越了进程的地址空间。所有位于栈上的变量、参数、返回值和其他放在栈上的东西，将被放置在有时称为线程本地（thread-local）存储的地方，即相关线程的栈。


### 核心问题：不可控调度
由于存在共享资源的代码片段，导致多线程执行时得到不确定的计算结果。

互斥（mutual exclusion）：保证了一个线程如果在临界区内执行，其他线程将被阻止进入临界区。

- 临界区（critical section）是访问共享资源的一段代码，资源通常是一个变量或数据结构。
- 竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致了令人惊讶的（也许是不希望的）结果。
- 不确定性（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确定的结果。
- 为了避免这些问题，线程应该使用某种互斥（mutual exclusion）原语。这样做可以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。