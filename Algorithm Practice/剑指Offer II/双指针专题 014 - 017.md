![[Pasted image 20230518210014.png]]

## [剑指 Offer II 014. 字符串中的变位词](https://leetcode.cn/problems/MPnaiL/)
给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的某个变位词。
换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。

---

**输入:** s1 = "ab" s2 = "eidbaooo"
**/:** True
**解释:** s2 包含 s1 的排列之一 ("ba").

---

**输入:** s1= "ab" s2 = "eidboaoo"
**输出:** False

#### 解题思路

1. 使用一个哈希表来存储字符串 `s1`
2. 维护一个窗口，使用另外一个哈希表存储窗口所对应的 `s2` 中的字符串及其数量。
3. 当两个哈希表中记录存在字符相同时，我们可以认为出现了变位词。

```go

func checkInclusion(s1 string, s2 string) bool {  
   // 条件判断， 当 s1 > s2 时，不存在变位词  
   if len(s1) > len(s2) {  
      return false  
   }  
   // 由于字符串只包含字母，因此可以维护一个长度26的数组替代哈希表  
   var cnt_s1 [26]byte  
   var cnt_s2 [26]byte  
   for i, ch := range s1 {  
      cnt_s1[ch-'a']++  
      cnt_s2[s2[i]-'a']++ // 同时记录两个表可以节约第一次比较时的时间  
   }  
   // 可以进行一次判断  
   if cnt_s1 == cnt_s2 {  
      return true  
   }  
   // 维护一个窗口来跟进数组中存储的字母数量  
   // 每一次循环，在表中加入右侧的字母，减去左侧的字母  
   n := len(s1)  
   for right := n; right < len(s2); right++ {  
      cnt_s2[s2[right-n]-'a']--  
      cnt_s2[s2[right]-'a']++  
      if cnt_s1 == cnt_s2 {  
         return true  
      }  
   }  
   // 没有找到变位词  
   return false  
}


```

## [剑指 Offer II 015. 字符串中的所有变位词](https://leetcode.cn/problems/VabMRr/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **变位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**变位词** 指字母相同，但排列不同的字符串。

---
**输入:** s = "cbaebabacd", p = "abc"
**输出:** [0,6]
**解释:**
起始索引等于 0 的子串是 "cba", 它是 "abc" 的变位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的变位词。

---
**输入:** s = "abab", p = "ab"
**输出:** [0,1,2]
**解释:**
起始索引等于 0 的子串是 "ab", 它是 "ab" 的变位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的变位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的变位词。

#### 解题思路

1. 基于题目可以发现，与14题类似的是，依然需要寻找变位词，但是这一次需要统计所有变位词的起始位置。
2. 那么基于这个理解，我们可以使用14题的解题思路，当发现出现变位词时，统计左窗口的指针下标。

```go
func findAnagrams(s2 string, s1 string) []int {  
   // 结果数组
   res := []int{}  
   // 条件判断， 当 s1 > s2 时，不存在变位词  
   if len(s1) > len(s2) {  
      return res  
   }  
   // 由于字符串只包含字母，因此可以维护一个长度26的数组替代哈希表  
   var cnt_s1 [26]byte  
   var cnt_s2 [26]byte  
   for i, ch := range s1 {  
      cnt_s1[ch-'a']++  
      cnt_s2[s2[i]-'a']++ // 同时记录两个表可以节约第一次比较时的时间  
   }  
   // 可以进行一次判断  
   if cnt_s1 == cnt_s2 {  
      res = append(res, 0)  
   }  
   // 维护一个窗口来跟进数组中存储的字母数量  
   // 每一次循环，在表中加入右侧的字母，减去左侧的字母  
   n := len(s1)  
   for right := n; right < len(s2); right++ {  
      cnt_s2[s2[right-n]-'a']--  
      cnt_s2[s2[right]-'a']++  
      // 找到变位词，进行统计  
      if cnt_s1 == cnt_s2 {  
         res = append(res, right-n+1)  
      }  
   }  
   return res  
}
```

## [剑指 Offer II 016. 不含重复字符的最长子字符串](https://leetcode.cn/problems/wtcaE1/)
给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长连续子字符串** 的长度。

---
**输入:** s = "abcabcbb"
**输出:** 3 
**解释:** 因为无重复字符的最长子字符串是 `"abc"，所以其`长度为 3。

---
**输入:** s = "bbbbb"
**输出:** 1
**解释:** 因为无重复字符的最长子字符串是 `"b"`，所以其长度为 1。

---
**输入:** s = "pwwkew"
**输出:** 3
**解释:** 因为无重复字符的最长子串是 `"wke"`，所以其长度为 3。
     请注意，你的答案必须是 **子串** 的长度，`"pwke"` 是一个_子序列，_不是子串。

---
**输入:** s = ""
**输出:** 0


#### 解题思路

1. 同样的，维护一个哈希表和一个窗口，哈希表记录了窗口中的字符对应数量。
2. 遍历整个字符串，每次更新哈希表时，判断是否有重复字符，并记录结果。
---
1. 上面这种方法，需要多次遍历哈希表来判断是否存在重复字符，因此可以尝试优化。
2. 当我们判断是否有重复字符时，其实是寻找哈希表中是否存在数量 `> 1` 的字符，因此我们可以转换思路，每当往哈希表中添加新字符时，判断该字符是否已存在于哈希表中来判断是否有重复字符。