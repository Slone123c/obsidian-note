[[剑指 Offer 60. n个骰子的点数]]

# 实现思路

- 

---
# 代码实现

```go
func dicesProbability(n int) []float64 {  
   // 初始化二维动态规划数组 dp，大小为 (n+1) x (6*n+1)。  
  
   // 1. n+1 行：dp数组的第一个维度大小为n+1，是因为我们需要在dp中表示掷0到n个骰子的情况。  
   // 其中dp[0][x]表示掷0个骰子的情况，但在这个问题中我们并不关心这一行的内容。  
   // dp[1][x]表示掷一个骰子的情况，dp[2][x]表示掷两个骰子的情况，依此类推，直到dp[n][x]表示掷n个骰子的情况。  
  
   // 2. 6n+1 列：dp数组的第二个维度大小为6n+1，是因为掷n个骰子可能产生的点数总和范围是从n（每个骰子都投1）到6n（每个骰子都投6）。  
   // 因此，我们需要足够的列来表示这个范围内的所有可能点数。由于数组下标从0开始，我们需要在列数上加1，以便容纳最大可能点数6n的情况。  
   dp := make([][]float64, n+1)  
   for i := range dp {  
      dp[i] = make([]float64, 6*n+1)  
   }  
  
   // 填充第一行，表示掷1个骰子时各点数出现的概率（都为 1/6）。  
   for i := 1; i <= 6; i++ {  
      dp[1][i] = 1 / 6.0  
   }  
  
   // 动态规划递推  
   // i 表示当前掷出骰子的数量  
   for i := 2; i <= n; i++ {  
      // j 表示当前骰子数量的可能点数和，例如只有2个骰子，那么总和可能是2(1+1) ～ 12(6+6)。  
      for j := i; j <= 6*i; j++ {  
         // 假设我们有2个六面骰子，即n=2。我们想要计算点数总和为7的概率，那么有以下组合:  
         /*            第一个骰子掷出1的概率为dp[1][1], 第二个骰子掷出6的概率为1/6，  
            以此类推，将两个概率相乘并叠加所有能够得出总和为7的概率。  
            1. 第一个骰子掷出1，第二个骰子掷出6。-- dp[1][1] * 1/6  
            2. 第一个骰子掷出2，第二个骰子掷出5。-- dp[1][2] * 1/6  
            3. 第一个骰子掷出3，第二个骰子掷出4。-- dp[1][3] * 1/6  
            4. 第一个骰子掷出4，第二个骰子掷出3。-- dp[1][4] * 1/6  
            5. 第一个骰子掷出5，第二个骰子掷出2。-- dp[1][5] * 1/6  
            6. 第一个骰子掷出6，第二个骰子掷出1。-- dp[1][6] * 1/6  
  
            所以掷出2个骰子和为7的概率为6 * 1/6 * 1/6 = 6/36 = 0.16667  
         */  
         // k 表示当前骰子的点数（1到6）。  
         // 遍历当前骰子的所有可能点数（1到6），然后根据前一个状态（投掷i-1个骰子）的概率来累加当前状态（i个骰子）的概率。  
         for k := 1; k <= 6; k++ {  
            // 如果 j-k 大于 0，即剩余的i-1个骰子的点数总和大于0。  
            // 如果j-k小于等于0，那么这个点数组合是无效的，因为骰子的点数总和不能小于1。  
            // 根据上面的例子，即 j = 7 的情况，我们就可以有7-1，7-2，7-3。7-4，7-5，7-6，6种情况，然后叠加他们算出最后的概率  
            if j-k > 0 {  
               dp[i][j] += dp[i-1][j-k] / 6  
            } else {  
               // 如果 j-k 小于等于 0，跳出循环。  
               break  
            }  
         }  
      }  
   }  
  
   // 创建一个结果切片 res。  
   res := make([]float64, 5*n+1)  
   // 提取 dp 计算的结果。  
   // n 表示掷出骰子的数量  
   // 这里n+i 的取值范围是n ~ n + 5n即 n ~ 6n，即投n个骰子可能的总和的范围  
   for i := 0; i <= 5*n; i++ {  
      res[i] = dp[n][n+i]  
   }  
  
   return res  
}
```